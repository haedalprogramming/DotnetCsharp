# MVC 디자인패턴 소개

## 목차
- [MVC 디자인패턴 소개](#mvc-디자인패턴-소개)
  - [목차](#목차)
  - [Software design pattern](#software-design-pattern)
    - [History](#history)
    - [Practice](#practice)
    - [Motif](#motif)
  - [Model–view–controller](#modelviewcontroller)
    - [History](#history-1)
    - [Components](#components)
      - [Model](#model)
      - [View](#view)
      - [Controller](#controller)
    - [Interactions](#interactions)
    - [Motivation](#motivation)
    - [Use in web applications](#use-in-web-applications)
  - [출처](#출처)
  - [다음](#다음)

---
## Software design pattern

소프트웨어 공학에서 디자인 패턴은 코드 작성 방법 측면에서 컴퓨터 프로그램의 비교적 작고 잘 정의된 측면(즉, 기능성)을 설명합니다.

패턴을 사용하는 것은 새로운 개념을 발명하기보다는 기존 개념을 활용하는 것을 목적으로 합니다. 이는 소프트웨어 개발 시간을 단축하고 결과 프로그램의 품질을 향상시킬 수 있습니다.

특히, 패턴은 소프트웨어 아티팩트로 구성되지 않습니다. 프로그래머가 사용하는 대부분의 개발 자원은 라이브러리와 같은 아티팩트를 사용하도록 코드베이스를 구성하는 것을 포함합니다(한 가지 예를 들면). 반면에 패턴을 사용하려면, 프로그래머는 패턴에 따라 코드를 작성합니다. 결과물은 패턴을 기반으로 한 것으로 인식될 수 있지만 매번 고유한 결과물이 됩니다.

일부 사람들은 패턴 사용을 소프트웨어 설계의 최선의 방법으로 간주합니다. 일부는 디자인 패턴 사용을 컴퓨터 프로그래밍에 대한 구조화된 접근 방식으로 간주합니다.

개념적으로, 디자인 패턴은 프로그래밍 패러다임보다는 더 구체적이고 알고리즘보다는 덜 구체적으로 설명될 수 있습니다.

### History

패턴은 1977년 크리스토퍼 알렉산더가 건축 개념으로 처음 제안했습니다 (참고: "The Pattern of Streets," JOURNAL OF THE AIP, 1966년 9월, Vol. 32, No. 5, pp. 273–278). 1987년, 켄트 벡과 워드 커닝햄은 패턴 언어를 프로그래밍에 적용하는 아이디어를 실험하기 시작했으며, 그해 OOPSLA 콘퍼런스에서 그 결과를 발표했습니다​. 이후 몇 년 동안 벡, 커닝햄 및 다른 사람들이 이 작업을 이어갔습니다.

디자인 패턴은 1994년 "Gang of Four" (GoF)라고 불리는 사람들이 저술한 책 "Design Patterns: Elements of Reusable Object-Oriented Software"가 출판된 후 컴퓨터 과학에서 인기를 얻었습니다​ ​. 같은 해, 첫 번째 Pattern Languages of Programming Conference가 열렸고, 이듬해에는 디자인 패턴을 문서화하기 위한 포틀랜드 패턴 리포지토리가 설립되었습니다. 이 용어의 범위는 여전히 논쟁의 여지가 있습니다.

### Practice

디자인 패턴은 검증된 개발 패러다임을 제공하여 개발 과정을 가속화할 수 있습니다. 효과적인 소프트웨어 설계는 구현이 진행될 때까지 명확하지 않을 수 있는 문제들을 고려해야 합니다. 새로 작성된 코드는 종종 시간이 지나야 감지되는 미묘한 문제들을 포함할 수 있으며, 이러한 문제들은 때때로 큰 문제를 일으킬 수 있습니다. 디자인 패턴을 재사용하면 이러한 문제를 방지하고, 패턴에 익숙한 사람들에게 코드 가독성을 향상시킬 수 있습니다.

소프트웨어 설계 기술은 더 광범위한 문제에 적용하기 어려운 경우가 많습니다. 디자인 패턴은 특정 문제에 얽매이지 않는 형식으로 문서화된 일반적인 해결책을 제공합니다.

### Motif

패턴은 프로그램 구성 요소(예: 클래스, 메서드 등)와 그들의 관계 집합으로서의 디자인 모티프, 즉 전형적인 마이크로 아키텍처를 설명합니다. 개발자는 패턴에 의해 설명된 문제를 해결하기 위해 이 모티프를 자신의 코드베이스에 맞게 조정합니다. 결과 코드는 선택한 모티프와 유사한 구조와 조직을 갖게 됩니다.

---
## Model–view–controller

![](../img/05_MVC_디자인패턴_소개/File_MVC-Process.svg)

모델-뷰-컨트롤러(MVC)는 관련 프로그램 로직을 세 가지 상호 연결된 요소로 나누는 사용자 인터페이스 개발에 일반적으로 사용되는 소프트웨어 디자인 패턴입니다. 이 요소들은 다음과 같습니다:

- 모델: 정보의 내부 표현
- 뷰: 사용자에게 정보를 제공하고 사용자의 입력을 수락하는 인터페이스
- 컨트롤러: 두 요소를 연결하는 소프트웨어

전통적으로 데스크톱 그래픽 사용자 인터페이스(GUI)에 사용되던 이 패턴은 웹 애플리케이션 설계에도 인기를 얻게 되었습니다. 인기 있는 프로그래밍 언어에는 이 패턴의 구현을 용이하게 하는 MVC 프레임워크가 있습니다.

### History

그래픽 사용자 인터페이스(GUI)의 초기 개발에서 중요한 통찰 중 하나인 MVC는 소프트웨어 구성 요소를 그들의 책임 측면에서 설명하고 구현하는 첫 번째 접근 방식 중 하나가 되었습니다​ ​.

트리그브 렌스카우그는 1970년대 후반 Xerox Palo Alto Research Center(PARC)에서 방문 과학자로서 Smalltalk-79를 작업하면서 MVC를 만들었습니다​ ​​ ​​ ​. 그는 사용자가 복잡한 데이터 집합과 상호작용하는 모든 프로그램에 사용할 수 있는 패턴을 원했습니다. 그의 초기 설계에는 모델, 뷰, 사물(thing), 편집기(editor) 네 부분이 있었습니다. 다른 Smalltalk 개발자들과 논의한 후, 그는 모델, 뷰, 컨트롤러로 구성된 최종 디자인을 확정했습니다​ ​.

최종 디자인에서 모델은 프로그램의 일부를 순수하고 직관적으로 표현합니다. 뷰는 모델의 데이터를 사용자에게 표시하고 사용자와 모델 간의 요청을 주고받는 시각적 표현입니다. 컨트롤러는 사용자 인터페이스의 조직적 부분으로, 화면에 여러 뷰를 배치하고 조정하며 사용자 입력을 받아 적절한 메시지를 기본 뷰에 보냅니다. 이 디자인에는 특정 뷰를 수정하는 데 사용되는 특수한 유형의 컨트롤러인 편집기도 포함되어 있으며, 이는 해당 뷰를 통해 생성됩니다​ ​.

Smalltalk-80은 이 디자인에서 발전된 MVC 버전을 지원합니다​ ​. 추상 뷰 및 컨트롤러 클래스와 다양한 일반 위젯을 나타내는 구체적인 하위 클래스를 제공합니다. 이 구조에서 뷰는 사용자에게 정보를 표시하는 방법을 나타내고, 컨트롤러는 사용자가 뷰와 상호작용하는 방법을 나타냅니다. 뷰는 모델 객체와도 연결되지만, 그 객체의 구조는 애플리케이션 프로그래머에게 맡겨집니다. Smalltalk-80 환경에는 주어진 모델, 뷰 및 컨트롤러의 구조를 나란히 볼 수 있는 개발 도구인 "MVC Inspector"도 포함되어 있습니다​ ​.

1988년, 두 명의 전 PARC 직원이 The Journal of Object Technology (JOT)에서 Smalltalk-80 개발자를 위한 일반적인 "프로그래밍 패러다임 및 방법론"으로 MVC를 소개하는 기사를 발표했습니다. 그러나 그들의 체계는 렌스카우그 등의 것과 Smalltalk-80 참고서에서 제시된 것과는 달랐습니다. 그들은 뷰를 모든 그래픽적 관심사를 포함하는 것으로 정의하고, 컨트롤러는 일반적으로 보이지 않는 객체로 정의하여 사용자 입력을 받고 하나 이상의 뷰와 상호작용하며 단 하나의 모델과 상호작용한다고 설명했습니다 .

MVC 패턴은 이후 발전하여, 계층형 모델-뷰-컨트롤러(HMVC), 모델-뷰-어댑터(MVA), 모델-뷰-프레젠터(MVP), 모델-뷰-뷰모델(MVVM) 등 다양한 변형을 낳았습니다 .

MVC 패턴의 웹 애플리케이션 사용은 1996년 NeXT의 WebObjects 도입 이후 증가했습니다. WebObjects는 원래 Objective-C로 작성되었고, MVC 원칙을 강화하는 데 기여했습니다. 나중에 WebObjects가 Java로 포팅되면서 Java 개발자들 사이에서도 MVC 패턴이 인기를 얻었습니다. 이후 Spring(2002년 10월 출시)과 같은 Java 프레임워크는 Java와 MVC 간의 강한 연계를 지속시켰습니다.

2003년, 마틴 파울러는 "Patterns of Enterprise Application Architecture"를 출판하며, MVC를 "입력 컨트롤러"가 요청을 받고, 모델 객체에 적절한 메시지를 보내고, 모델 객체로부터 응답을 받아 적절한 뷰에 표시하는 패턴으로 제시했습니다​ ​. 이는 루비 온 레일즈 웹 애플리케이션 프레임워크(2004년 8월)에서 채택된 접근 방식과 유사합니다. Django 프레임워크(2005년 7월, Python용)는 "모델 템플릿 뷰"(MTV) 패턴을 제시하여, 뷰가 모델에서 데이터를 가져와 템플릿에 전달하여 표시하는 방식입니다 . Rails와 Django는 빠른 배포에 중점을 두어 전통적인 기업 환경 밖에서도 MVC의 인기를 높였습니다.

### Components

#### Model
이 패턴의 중심 구성 요소입니다. 애플리케이션의 동적 데이터 구조로, 사용자 인터페이스와 독립적입니다. 모델은 애플리케이션의 데이터, 로직 및 규칙을 직접 관리합니다. Smalltalk-80에서는 모델 타입의 설계가 전적으로 프로그래머에게 맡겨져 있습니다. WebObjects, Rails, Django에서는 모델 타입이 일반적으로 애플리케이션 데이터베이스의 테이블을 나타냅니다.

#### View
차트, 다이어그램 또는 테이블과 같은 정보의 모든 표현을 의미합니다. 동일한 정보에 대한 여러 뷰가 가능하며, 예를 들어 관리용 막대 차트와 회계용 표 형식 뷰가 있을 수 있습니다.

Smalltalk-80에서는 뷰가 모델의 시각적 표현일 뿐이며, 사용자 입력을 처리하지 않습니다. WebObjects에서는 뷰가 메뉴나 버튼과 같은 완전한 사용자 인터페이스 요소를 나타내며, 사용자 입력을 받습니다. 두 시스템 모두에서 뷰는 범용적이고 조합 가능한 것으로 간주됩니다.

Rails와 Django에서는 뷰의 역할이 HTML 템플릿에 의해 수행되므로, 뷰는 직접적인 사용자 인터페이스 위젯을 나타내기보다는 브라우저 내 사용자 인터페이스를 지정합니다. (Django에서는 이를 "템플릿"이라고 부릅니다.) 이 접근 방식은 작은, 조합 가능한 뷰에 대한 강조를 상대적으로 줄이고, 일반적으로 각 Rails 뷰는 특정 컨트롤러 액션과 일대일 관계를 가집니다.

Smalltalk-80 뷰는 모델 및 컨트롤러와 통신하는 반면, WebObjects에서는 뷰가 컨트롤러와만 통신하고, 컨트롤러가 모델과 통신합니다. Rails와 Django에서는 뷰/템플릿이 클라이언트에 응답을 준비할 때 컨트롤러/뷰에 의해 사용됩니다.

#### Controller
입력을 받아 모델이나 뷰에 대한 명령으로 변환합니다.

Smalltalk-80 컨트롤러는 버튼 클릭이나 마우스 이동과 같은 사용자 입력 이벤트를 처리합니다. 각 컨트롤러는 항상 하나의 뷰 및 모델과 연결되지만, 하나의 모델 객체는 여러 다른 컨트롤러로부터 입력을 받을 수 있습니다. 오직 하나의 "활성" 컨트롤러만이 주어진 시간에 사용자 입력을 받으며, 전역 윈도우 관리 객체가 현재 활성 컨트롤러를 설정하는 책임을 집니다. 사용자 입력이 모델의 변경을 유도하면, 컨트롤러는 모델에 변경을 신호하지만, 모델이 자신의 뷰에 업데이트를 알리는 책임을 집니다.

WebObjects에서는 뷰가 사용자 입력을 처리하고, 컨트롤러가 뷰와 모델 간의 중재 역할을 합니다. 애플리케이션당 하나의 컨트롤러만 있거나 창당 하나의 컨트롤러가 있을 수 있습니다. 애플리케이션별 로직의 대부분은 컨트롤러에 있습니다.

Rails에서는 클라이언트로부터 서버 애플리케이션에 도착한 요청이 "라우터"로 보내져, 특정 컨트롤러의 특정 메서드로 매핑됩니다. 해당 메서드 내에서 컨트롤러는 요청 데이터와 관련 모델 객체와 상호작용하며, 뷰를 사용하여 응답을 준비합니다. 일반적으로 각 뷰에는 연관된 컨트롤러가 있습니다. 예를 들어, 애플리케이션에 클라이언트 뷰가 있다면, 연관된 Clients 컨트롤러도 있을 것입니다. 그러나 개발자는 원하는 경우 다른 종류의 컨트롤러를 만들 수 있습니다.

Django는 이 역할을 수행하는 객체를 컨트롤러 대신 "뷰"라고 부릅니다. Django 뷰는 웹 요청을 받고 웹 응답을 반환하는 함수입니다. 응답을 생성하기 위해 템플릿을 사용할 수 있습니다.

### Interactions

애플리케이션을 모델, 뷰, 컨트롤러 구성 요소로 나누는 것 외에도, MVC 디자인 패턴은 이 세 구성 요소 간의 상호작용을 정의합니다:

- 모델은 애플리케이션의 데이터를 관리하는 역할을 합니다. 모델은 컨트롤러로부터 사용자 입력을 받습니다.
- 뷰는 모델의 프레젠테이션을 특정 형식으로 렌더링합니다.
- 컨트롤러는 사용자 입력에 응답하고 데이터 모델 객체에 대한 상호작용을 수행합니다. 컨트롤러는 입력을 받고, 선택적으로 이를 검증한 후 모델에 전달합니다.

다른 소프트웨어 패턴과 마찬가지로, MVC는 문제에 대한 "핵심 해결책"을 표현하면서 각 시스템에 맞게 조정될 수 있도록 합니다. 특정 MVC 디자인은 여기서 설명한 전통적인 설명과 상당히 다를 수 있습니다.

### Motivation

앨런 케이가 2003년에 쓴 글에 따르면, MVC의 초기 동기는 어떤 객체에 대해서도 그래픽 인터페이스를 만들 수 있게 하는 것이었습니다. 이는 리처드 포슨의 책 《Naked Objects》에 자세히 설명되어 있습니다.

PARC에서 MVC를 창안한 트리그브 렌스카우그는 "MVC는 사용자가 크고 복잡한 데이터 세트를 제어하는 문제에 대한 일반적인 해결책으로 구상되었습니다"라고 썼습니다.

1991년 Carleton 대학교의 컴퓨터 과학 교수 Wilf LaLonde와 John Pugh는 그들의 안내서 《Inside Smalltalk》에서 Smalltalk-80 스타일 MVC의 장점을 다음과 같이 설명했습니다:

- 프레젠테이션과 데이터의 독립성, 예를 들어 하나의 모델에 대해 동시에 여러 뷰를 가질 수 있음
- 조합 가능한 프레젠테이션 위젯, 예를 들어 하나의 뷰를 다른 뷰의 하위 뷰로 사용할 수 있음
- 입력 모드의 전환 가능성, 런타임 중에 하나의 컨트롤러를 다른 것으로 교체하여 입력 모드를 변경할 수 있음
- 입력과 출력 처리의 독립성, 컨트롤러와 뷰의 별도의 책임을 통해 달성됨

### Use in web applications

원래 데스크톱 컴퓨팅을 위해 개발되었지만, MVC는 주요 프로그래밍 언어에서 월드 와이드 웹 애플리케이션 설계로 널리 채택되었습니다. 여러 웹 프레임워크가 이 패턴을 구현하기 위해 만들어졌습니다. 이러한 소프트웨어 프레임워크는 주로 MVC 책임이 클라이언트와 서버 간에 어떻게 나뉘는지에 따라 해석이 다릅니다.

초기의 MVC 프레임워크는 거의 모든 모델, 뷰, 컨트롤러 로직을 서버에 배치하는 얇은 클라이언트 접근 방식을 취했습니다. 이 접근 방식에서 클라이언트는 컨트롤러에 하이퍼링크 요청이나 폼 제출을 보내고, 뷰로부터 완전하고 업데이트된 웹 페이지(또는 기타 문서)를 받습니다. 모델은 전적으로 서버에 존재합니다. 후속 프레임워크는 Ajax를 사용하여 데이터를 동기화하면서 MVC 구성 요소가 일부 클라이언트에서 실행될 수 있도록 허용했습니다.

---

---
## 출처
 - [Wikipedia Software design pattern](https://en.wikipedia.org/wiki/Software_design_pattern)
 - [Wikipedia Model–view–controller](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller)

---
## [다음](./06_REST_API_소개.md)



